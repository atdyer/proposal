\documentclass[../../proposal.tex]{subfiles}

\begin{document}

Called a third pillar of science, computation is an indispensible tool
for scientists and engineers who simulate physical and natural
processes.  Recent studies on reliability, reproducibility of results,
and productivity have brought forth concern that existing practices of
constructing scientific software are inadequate and limiting the pace
of technological advancement.  A disconnect between existing modern
software engineering practice and scientific computation has become
apparent and must be addressed.  Additionally, the unique challenges
facing developers of scientific software, namely the lack of test
oracles, software lifetimes and evolving needs that span decades, and
the competing objectives of performance, maintainability, and
portability, must also be recognized.

I seek to address fundamental design and quality assurance challenges
that are intrinsic to scientific computation and engineering software
design.  While numerous directions might be taken, my premise and
motivating viewpoint is the central role that modeling can and must
play in the process of designing and working with scientific programs. 
Culturally, the fit may be a natural one: scientists and engineers are
accustomed to working with models anyway, and with the kind of
automatic, push-button analysis supported by some state-based
formalisms, those who develop software can focus on modeling and design
instead of theorem proving.

Although the tools and techniques most identified with scientific
computation are those of numerical analysis---where error prediction,
stability, and convergence are central concerns---such an enterprise
offers little guidance in the development process, where early
decisions about decomposition and organization establish program
structure.  I suggest an approach that separates concerns: isolating
the structural and behavioral components from the numerics, allowing
scientists and engineers to more effectively reason about the programs
they create.  The approach is well-suited for lightweight tools like
Alloy~\cite{jackson2012}, a state-based formalism that combines
declarative modeling and bounded model checking.

\end{document}