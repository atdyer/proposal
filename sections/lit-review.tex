\documentclass[../../proposal.tex]{subfiles}

\begin{document}

Despite broad and recognized impacts, the field of scientific computation faces a number of challenges.  Meeting quality and reproducibility standards is a growing concern~\cite{}, as is productivity~\cite{}.  Not merely anecdotes, numerous empirical studies of software ``thwarting attempts at repetition or reproduction of scientific results'' have been cataloged in a recent article by Storer~\cite{}, along with their concomitant effects, including widespread inability to reproduce results and subsequent retractions of papers in scientific journals.  Productivity problems are also reported, which Faulk et al.~\cite{} refer to as a \emph{productivity crisis} because of ``frustratingly long and troubled software development times'' and difficulty achieving portability requirements and other goals.

Source of difficulty may stem from fundamental characteristics of the problem domain, along with cultural and development practices within it.  For instance, projects are often undertaken, as one might imagine, for the purpose of advancing scientific goals, so results may constitute novel findings that are difficult to validate.  In the absence of test oracles, developers may have to settle for plausibility checks based on, say, conservation laws or other principles that are expected to hold.  Then, if the software is successful, its lifetime may span a 20 or 30 year period, starting with development and then moving through hardware upgrades and evolving requirements that are intended to keep up with ongoing scientific advancements.  Development priorities are such that traditional software engineering concerns, like time to market and producing highly maintainable code, may receive relatively less attention compared with performance and hardware utilization~\cite{}.

Proposals to address quality and productivity concerns are varied.  Storer~\cite{} places new and suggested approaches into broad categories of (a) software processes, including agile methods, (b) quality assurance practices, including testing, inspection, and continuous integration, and (c) design approaches, including component architectures and design patterns.  In the category of quality assurance practices, he adds formal methods, noting a couple of experience reports, but also observing that such approaches have received considerably less attention in the scientific programming community, possibly due to ``the additional challenge of verifying programs that manage floating point data.''

\end{document}