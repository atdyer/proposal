# Notes and sources for sparse matrices

## Libraries and Features

### ITPACK

* Solver only, user must build CSR format (symmetric and non-symmetric supported)

### ITPACKV

* Adaptation of ITPACK for vector computers
* Used by ADCIRC
* [ELL format](https://web.ma.utexas.edu/CNA/ITPACK/manuals/userv2d/node3.html)

### PETSc

* Suite of data structures and routines for scalable parallel solutions of scientific applications.
* Parallel sparse matrix data structures --- four different data structures, each appropriate for different class of problems
* Data structures are still very low level and require manual assembly across MPI

### Pardiso

* Solver only, no data abstractions so supported format must be assembled manually

### Armadillo

* Sparse matrix class that stores CSC format

### Eigen

* Sparse matrix class using variant of CSR/CSC, built using array of triplets of row/col/val

### Numpy

* Many sparse matrix formats, conversions between them.

## Literature Review

### Specifying and Verifying Sparse Matrix Codes

**Author.**

Arnold et al.

**Abstract.**

Sparse matrix formats are typically implemented with low-level imperative programs. The optimized nature of these implementations hides the structural organization of the sparse format and complicates its verification. We define a variable-free functional language (LL) in which even advanced formats can be expressed naturally, as a pipeline-style composition of smaller construction steps. We translate LL programs to Isabelle/HOL and describe a proof system based on parametric predicates for tracking relationship between mathematical vectors and their concrete representations. This proof theory automatically verifies full functional correctness of many formats. We show that it is reusable and extensible to hierarchical sparse formats.

**Notes.**

The authors design a little language (LL) for describing sparse matrix codes and show how that language can be used to describe a number of formats.

The authors describe a proof method for automatic verification of sparse matrix codes written in LL.

The authors evaluate the reusability of proof rules in their theory and its extensibility to proving additional formats.

The authors show that the LL language and verifier can accommodate complex sparse matrix formats, and prove full functional correctness of operations on such formats.

No actual code is created, but the authors are working on a compiler to automatically generate efficient low-level code from LL programs.

Sparse matrix formats usually constructed as a sequence of transformations, but efficient imperative implementations usually fuse these distinct steps, complicating code comprehension and maintenance.

Arguments presented by the authors for full functional verification of sparse matrix codes:
* Classical static typing is insufficient for static bug detection because these programs contain array indirection, whose memory safety would be typically guaranteed only with run-time safety checks.
* Synthesis of sparse matrix programs and discovery of new formats (outside scope of this paper).

### A Relational Approach to the Compilation of Sparse Matrix Programs

**Author.**

Kotlyar et al.

**Abstract.**

We present a relational algebra based framework for compiling efficient sparse matrix code from dense DO-ANY loops and a specification of the representation of the sparse matrix. We present experimental data that demonstrates that the code generated by our compiler achieves performance competitive with that of hand-written codes for important computational kernels.

**Notes.**

The authors point out that rather than explicitly using sparse matrix formats, it is common to give the compiler a dense matrix program and allow the compiler to decide how and when to user sparse matrices instead. Their approach however, is to generate sparse matrices given user-defined storage formats. This is accomplished by describing formats as relations and the execution of loops nests as evaluation of relational queries.

Their abstractions are essentially the same that we use: Matrices and vectors are modeled as relations that hold indices and values.

Their approach only aims to solve this problem for DOALL loops and loops with reductions.

### Loop and Data Transformations for Sparse Matrix Code

**Author.**

Venkat et al.

**Abstract**

This paper introduces three new compiler transformations for representing and transforming sparse matrix computations and their data representations. In cooperation with run-time inspection, our compiler derives transformed matrix representations and associated transformed code to implement a variety of representations targeting different architecture platforms. This systematic approach to combining code and data transformations on sparse computations, which extends a polyhedral transformation and code generation framework, permits the compiler to compose these transformations with other transformations to generate code that is on average within 5% and often exceeds manually-tuned, high-performance sparse matrix libraries CUSP and OSKI. Additionally, the compiler-generated inspector codes are on average 1.5 faster than OSKI and perform comparably to CUSP, respectively.

### Model-Driven Engineering and Optimizing Compilers: A Bridge Too Far?

**Author.**

Floch et al.

**Abstract.**

A primary goal of Model Driven Engineering (MDE) is to reduce the cost and effort of developing complex software systems using techniques for transforming abstract views of software to concrete implementations. The rich set of tools that have been developed, especially the growing maturity of model transformation technologies, opens the possibility of applying MDE technologies to transformation-based problems in other domains.

In this paper, we present our experience with using MDE technologies to build and evolve compiler infrastructures in the optimizing compiler domain. We illustrate, through our two ongoing research compiler projects for C and a functional language, the challenging aspects of optimizing compiler research and show how mature MDE technologies can be used to address them. We also identify some of the pitfalls that arise from unrealistic expectations of what can be accomplished using MDE and discuss how they can lead to unsuccessful and frustrating application of MDE technologies.