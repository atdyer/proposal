% \documentclass[11pt,conference]{IEEEtran}
\documentclass[sigconf]{acmart}

\usepackage{listings}
\usepackage{tikz}
\usepackage[]{algorithm2e}

\usetikzlibrary{matrix, fit}
\usetikzlibrary{backgrounds}
\usetikzlibrary{positioning}
\usetikzlibrary{cd}

\input{models/alloy.tex}

\begin{document}
\pagestyle{plain}
\title{Translation Sections}
\maketitle

\section{Modeling Sparse Matrix Format Translations}

% https://www.mcs.anl.gov/petsc/documentation/linearsolvertable.html
% http://www.netlib.org/utk/people/JackDongarra/la-sw.html
The translation of a sparse matrix from one format to another may be necessary in a number of scenarios.  For example, it is common practice to assemble a sparse matrix using a format that is efficient for incremental assembly and to translate the fully assembled matrix to a format that is efficient for use in a solver.  In the context of ADCIRC++, we wish to compare the performance of a number of solvers in a number of different storm surge scenarios.  
Due to differences in solution technique in combination with floating point error propagation, the results generated by various solvers may not be exactly equivalent.  Therefore, in order to ensure that the same problem is being solved in each test case, a comparison of solutions is not sufficient.  Rather, we must show that the same matrix--i.e., the same system of equations--is being used across solvers, regardless of format.

ADCIRC and ADCIRC++ both use the ELL format in conjuction with the ITPACKV solver.  The format most commonly used in the solvers we wish to test (TODO: ITPACK, Pardiso, etc.) is the Compressed Sparse Row (CSR) format, and so we will model the ELL to CSR translation in this section.  A similar approach is to be taken for other formats, including the Block Compressed Sparse Row (BSR) used in the cuSPARSE library, and the Compressed Sparse Column (CSC) format used in the Armadillo library.

\LinesNumbered
\begin{algorithm}
\input{algorithms/ellcsr.tex}
\caption{The ELL to CSR translation algorithm.}
\label{algorithm:ellcsr}
\end{algorithm}
\LinesNotNumbered

An ELL to CSR translation algorithm is provided by the SPARSEKIT~\cite{sparsekit} library, and a Pythonic listing of this algorithm is found in \figurename~\ref{algorithm:ellcsr}.  The algorithm works by iterating over each stored column of each row in the ELL data structure.  If it is non-zero, the current value and its column index are copied in to the next available location in the corresponding CSR arrays, and the ending IA index for that row is incremented.

\begin{figure}
\input{models/ellcsr-0.tex}
\caption{The ELL to CSR Model}
\label{alloy:csrell}
\end{figure}

The translation from ELL to CSR in Alloy is performed by quantifying the state of the algorithm at every step in the innermost loop.  As seen in Algorithm~\ref{algorithm:ellcsr}, there are three variables used for indexing, $i$, $k$, and $kpos$, that need to be quantified.  The values of $i$ and $k$ are easily generated in Alloy using an \textbf{all} statement, but the value of $kpos$ is less straightforward.
It can optionally increase by one on line 8, at the end of the innermost loop, depending on whether or not the current matrix value is nonzero.
%It can optionally increase by one at the end of the innermost loop, depending on whether or not the current matrix value is nonzero.
%As a result, the value of $kpos$ at the end of the $i$ loop may not be the same as during the $k$ loop.
As a result, the value of $kpos$ at line 9, where an IA value is set, may not be the same as the value of $kpos$ at lines 6 and 7, where values of A and JA are set.
Therefore, we model the value of $kpos$ as a sequence of integers in which the value at index $it$ is the value of $kpos$ before line 8 and the value at index $it+1$ is the value of $kpos$ after line 8.
%Therefore, we model the value of $kpos$ as a sequence of integers in which the value at index $it$ is the value of $kpos$ at the \emph{beginning} of the current $k$ loop, and the value at index $it+1$ is the value of $kpos$ at the \emph{end} of the current $k$ loop.  
This sequence is generated using the \textbf{genkpos} predicate found in \figurename~\ref{alloy:csrell}.  With the sequence generated, the value of $kpos$ at any location inside of the algorithm can now be determined using the values of $i$ and $k$.

The \textbf{ellcsr} predicate generates a sequence of $kpos$ values using the \textbf{genkpos} predicate\footnote{The $kpos$ sequence is generated using \textbf{some}, which here is a higher-order quantification.  Alloy cannot perform higher-order quantification, but is able to eliminate it in some cases, such as this one, by using skolemization.  We expect there to be only a single possible sequence of $kpos$ values for any given translation, and so the \textbf{one} quantifier should be used instead.  This quantification cannot be eliminated using skolemization, and so we have verified this property using Alloy*, an extension of Alloy that permits higher-order quantification~\cite{alloy*}.} and performs the translation using the same indexing pattern used in the algorithm.  Indeed, the value of $kpos$ could be generated directly within the \textbf{ellcsr} predicate, but we found that the separation made it easier to reason about two key components separately: (1) the nondeterministic evolution of the $kpos$ value and (2) the correct indexing of values.

For a translation to be considered valid, the final state must preserve the representation invariant of the target format as well as represent the same abstract matrix as the original format.  Intermediate states, however, do not need to preserve the representation invariant.  The Alloy assertion used to model this relationship is shown in \figurename~\ref{alloy:csrell}, which states that if the ELL matrix $e$ is a valid representation of the abstract matrix $m$ and the translation is applied, giving the CSR matrix $c$, then it follows that $c$ is a valid CSR matrix that represents the abstract matrix $m$.  The scope used for this check shows that the translation is valid for matrices up to 6$\times$6.

\subsection{In-Place Translation}

In SPARSEKIT~\cite{sparsekit}, the ELL to CSR translation is a Fortran subroutine that receives five arrays as input: two arrays, COEF and JCOEF, representing the ELL format, and three arrays, A, JA, and IA, representing the CSR format.  The target CSR arrays must be allocated before calling the subroutine, and must contain enough memory to store the sparse matrix.  The only way to ensure that there is enough memory allocated is to either count the number of non-zero values in the ELL matrix before calling the subroutine or naively allocate enough memory to hold a densely populated ELL matrix (one in which there are no padding values).  This presents two possible performance issues: (1) counting the number of non-zero values requires looping through the entire ELL matrix, and (2) depending on the size and sparsity of the matrix, allocating enough memory to perform the translation may not be possible on certain hardware.

An in-place translation from ELL to CSR could sidestep these issues, provided there is no requirement that the original ELL matrix be valid after the translation occurs.  
%By simple inspection we can infer that the size of the A and JA arrays will always be less than or equal to the size of the COEF and JCOEF arrays.  
During the translation, all padding values are removed from COEF and JCOEF to produce A and JA, respectively, and so we can infer that in the case where there are no padding values present, the arrays will be equivalent.  Therefore, we know that the maximum amount of memory required to store A and JA is equal to the amount required to store COEF and JCOEF.  So if an in-place translation is possible, the number of non-zero values is not required and the only memory allocation required is for the IA array, the size of which is always one more than the number of rows in the matrix.

\LinesNumbered
\begin{algorithm}
\input{algorithms/ellcsrip.tex}
\caption{The in-place ELL to CSR translation algorithm.}
\label{algorithm:ellcsrip}
\end{algorithm}
\LinesNotNumbered

Algorithm~\ref{algorithm:ellcsrip} shows the in-place translation.  It is equivalent to Algorithm~\ref{algorithm:ellcsr}, except for lines 7 and 8 which are modified to perform the translation in-place.
In order to determine if this algorithm performs a valid translation, 
we must show that once a value has been written to an index, that index is not read from in subsequent iterations.  In this algorithm, the values used to index into the arrays, $kpos$ and $idx$, are always increasing.  At every iteration, the value of $idx$ increases by exactly one and the value of $kpos$ optionally increases by one.  Therefore, we can conclude that $kpos$ indices being used to overwrite existing values will always be less than or equal to $kpos$ indices being used to read existing values.
%Therefore, we can conclude that indices being overwritten using the $kpos$ index will always be less than or equal to values being read using the $idx$ index.  
This means that once a value is written to an index, that index will never again be used by the algorithm to read that value, and so an in-place translation is possible.

\begin{figure}
\input{models/ellcsrip.tex}
\caption{Alloy assertion that the ELL to CSR translation can be performed in-place.}
\label{alloy:csrellip}
\end{figure}

This property can be formally verified using Alloy, as shown in \figurename~\ref{alloy:csrellip}.  The assertion used here states that for valid ELL matrices up to size 15$\times$15, the value of $kpos$ is less than or equal to the value of $idx$ at every iteration of the translation algorithm.  Indeed, the assertion holds and so we have formally verified that within scope, the algorithm can be performed in-place.  While visual inspection and careful reasoning about the algorithm led us to the same conclusion, the benefits of using Alloy here are twofold: (1) a formal verification provides confidence that our reasoning is sound, and (2) this type of modeling gives valuable insight into how to reason about the types of algorithms commonly found in scientific and engineering software, many of which may not be as easy to analyze analytically.

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,sparse,mybib}

\end{document}