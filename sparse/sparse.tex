\documentclass[11pt,conference]{IEEEtran}

\usepackage{cite}
\usepackage{url}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\begin{document}

\title{Sparse}
\author{
  \IEEEauthorblockN{Tristan Dyer}
  \and
  \IEEEauthorblockN{John Baugh}
}

\maketitle

\section{Introduction}

Computations on sparse matrices are prevalent in scientific and engineering software.  Sparse matrix data formats are able to compress large matrices with a small number of non-zero elements into a more efficient representation.  The development of software that makes use of sparse matrices is a tedious and often error-prone task because of the myriad data formats and complexities involved in tuning the operations on these formats to achieve an efficient implementation.

Characterize sparse matrix codes. Written in imperative languages like C and Fortran.  Structure of sparse format interspersed with computation.  

A number of approaches have been taken in order to address these issues.  Object-oriented libraries such as PETSc~\cite{petsc2019} and Eigen~\cite{eigenweb2010} provide data abstractions targeted towards specific classes of solvers.  These libraries provide templates that allow developers to assemble sparse matrices without having to address the structural complexities that a specific format may present.  These matrices can then be used in a variety of solvers, given that the format is supported.

Alternatively, there is a body of research that takes the approach of designing and building compilers capable of automatically making decisions about sparse matrix formats and operations.  Some compilers~\cite{bik1995, bik1996} allow developers to work with dense matrices in code, generating a sparse matrix program at compile time.  Others~\cite{kotlyar1997} aim to provide the compiler with an abstract description of a sparse format, allowing it to make automatic optimizations in code that accesses the sparse data.

Rather than hiding the complexities of sparse matrix formats by providing data abstractions in code or automatic optimizations in compilers, we propose an approach that allows developers to reason about these complexities.  Elements of this approach include declarative modeling and automatic, push-button analysis using the Alloy Analyzer~\cite{jackson2012}, a lightweight bounded model checking tool.  Characteristics of sparse matrices, with their numerous representations and ...hard-to-get-right-implementation-details... are approached using abstraction based methods~\cite{clarke1994}, including data abstraction~\cite{dingel1995} and predicate abstraction~\cite{graf1997}, data and functional refinement~\cite{woodcock1996}, and other techniques, manually, as part of a modeling process...

The benefits of this approach lie in its generality.  By using Alloy to perform the modeling and analysis, the modeler may choose the programming language that best fits their needs when transitioning from model to implementation.
Can reason about existing software.
Can reason about design of new sparse matrix libraries.
Can reason about compiler design.

\section{Lightweight Formal Methods}

An additional aspect of lightweight formal methods is an incremental style of modeling, which tools like Alloy support by offering immediate feedback while models are being constructed: we start with a minimal set of constraints and ``grow'' them via conjunction.

\subsection{Alloy}

The tool used in this research is Alloy, a declarative modeling language combining first-order logic with relational calculus and associated quantifiers and operators, along with transitive closure.  It offers rich data modeling features based on class-like structures and an automatic form of analysis that is performed within a bounded scope using a SAT solver.  For \emph{simulation}, the analyzer can be directed to look for instances satisfying a property of interest.  For \emph{checking}, it looks for an instance violating an assertion: a counterexample.  The approach is \emph{scope complete} in the sense that all cases are checked within user-specified bounds.  Alloy's logic supports three distinct styles of expression, that of predicate calculus, navigation expressions, and relational calculus.  The language used for modeling is also used for specifying properties of interest and assertions.  Alloy supports expressions with integer values and basic arithmetic operations.

\subsection{Data Abstraction}

Proof obligations: mathematical formula to be proven in order to ensure that a component is correct.

Start example here.

\subsection{Data Refinement}

The process of data refinement involves removing nondeterminism, or uncertainty, from an abstract model~\cite{woodcock1996}.  While an abstract model may omit certain design choices, a refinement can resolve some of these choices, removing uncertainty and approaching the level of a concrete implementation.

Diagram of refinement here.

Abstraction function and representation invariant discussion.

Continue example with refinement here.

\section{Sparse Matrix Models}

In this section we describe four models of sparse matrices.  First we describe an abstract model of a sparse matrix that refrains from including any implementation specific details; it does not directly describe any specific sparse matrix format.  Then we describe three refinements of this model: the first is a model of the DOK format, the second is a model of the ELL format, and the third is a model of the CSR format.  In each of these refinements we determine the appropriate representation invariants as well as the abstraction functions and show that the refinement is valid.

\subsection{Abstract Sparse Matrix}

\begin{figure}
\centering
Value Model.
\caption{Abstract Model of Values}
\label{mod:value}
\end{figure}

Before modeling sparse matrices, we first create an abstraction of the values that they contain, as shown in \figurename~\ref{mod:value}.  Because the distinction that separates sparse matrices from dense ones is the removal of zeros, we represent values as either zero or non-zero.  The Value signature represents any numerical value and the Zero signature, and extension of Value, represents the value zero.  So depending on the scope, the set of values available is

\begin{displaymath}
Value = \{Zero, Value_0, Value_1, \ldots, Value_n\}
\end{displaymath}

An abstract model of a sparse matrix is given in \figurename~\ref{mod:abstract}.

\begin{figure}
\centering
Abstract Model.
\caption{Abstract Sparse Matrix Model.}
\label{mod:abstract}
\end{figure}

\subsection{DOK Format}

DOK.

\subsection{ELL Format}

ELL.

\subsection{CSR Format}

CSR.

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,sparse,mybib}

\end{document}
